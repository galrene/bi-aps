$date
	Mon Oct 24 17:32:40 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var wire 1 ! write_enable $end
$var wire 32 " data_to_mem [31:0] $end
$var wire 32 # address_to_mem [31:0] $end
$var reg 1 $ clk $end
$var reg 1 % reset $end
$scope module simulated_system $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 1 ! write_enable $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instruction [31:0] $end
$var wire 32 ( data_to_mem [31:0] $end
$var wire 32 ) data_from_mem [31:0] $end
$var wire 32 * address_to_mem [31:0] $end
$scope module CPU $end
$var wire 32 + PC [31:0] $end
$var wire 1 ! WE $end
$var wire 32 , address_to_mem [31:0] $end
$var wire 1 $ clk $end
$var wire 32 - data_to_mem [31:0] $end
$var wire 32 . readData [31:0] $end
$var wire 1 % reset $end
$var wire 1 / zero $end
$var wire 32 0 writeData [31:0] $end
$var wire 32 1 rs1 [31:0] $end
$var wire 1 2 regWriteControl $end
$var wire 1 3 memWriteControl $end
$var wire 32 4 memToRegRes [31:0] $end
$var wire 32 5 instruction [31:0] $end
$var wire 32 6 immOp [31:0] $end
$var wire 3 7 immControl [2:0] $end
$var wire 32 8 data_from_mem [31:0] $end
$var wire 32 9 branchTarget [31:0] $end
$var wire 1 : branchOutcome $end
$var wire 32 ; branchJalrMuxIn [31:0] $end
$var wire 1 < branchJalrControl $end
$var wire 32 = branchJalReturnAddr [31:0] $end
$var wire 1 > branchJalControl $end
$var wire 1 ? branchBltControl $end
$var wire 1 @ branchBeqControl $end
$var wire 32 A PC_cable [31:0] $end
$var wire 1 B MemToRegControl $end
$var wire 32 C AluSrcOut [31:0] $end
$var wire 1 D ALUSrcControl $end
$var wire 32 E ALUOut [31:0] $end
$var wire 3 F ALUControl [2:0] $end
$var reg 32 G PCPlus4 [31:0] $end
$var reg 32 H program_counter [31:0] $end
$scope module ALUSrc_mux $end
$var wire 32 I out [31:0] $end
$var wire 1 D sig $end
$var wire 32 J b [31:0] $end
$var wire 32 K a [31:0] $end
$upscope $end
$scope module BranchJalAndJalr_mux $end
$var wire 32 L b [31:0] $end
$var wire 32 M out [31:0] $end
$var wire 1 N sig $end
$var wire 32 O a [31:0] $end
$upscope $end
$scope module BranchJalr_mux $end
$var wire 32 P out [31:0] $end
$var wire 1 < sig $end
$var wire 32 Q b [31:0] $end
$var wire 32 R a [31:0] $end
$upscope $end
$scope module BranchOutcome_mux $end
$var wire 32 S a [31:0] $end
$var wire 32 T b [31:0] $end
$var wire 32 U out [31:0] $end
$var wire 1 : sig $end
$upscope $end
$scope module MemToReg_mux $end
$var wire 32 V a [31:0] $end
$var wire 32 W b [31:0] $end
$var wire 32 X out [31:0] $end
$var wire 1 B sig $end
$upscope $end
$scope module alu $end
$var wire 32 Y srcB [31:0] $end
$var wire 32 Z srcA [31:0] $end
$var wire 3 [ ALUControl [2:0] $end
$var reg 32 \ ALUResult [31:0] $end
$var reg 1 / zero $end
$upscope $end
$scope module branchAdder $end
$var wire 32 ] b [31:0] $end
$var wire 32 ^ res [31:0] $end
$var wire 32 _ a [31:0] $end
$upscope $end
$scope module cu $end
$var wire 7 ` opcode [6:0] $end
$var wire 32 a instruction [31:0] $end
$var wire 7 b funct7 [31:25] $end
$var wire 3 c funct3 [14:12] $end
$var reg 3 d ALUControl [2:0] $end
$var reg 1 D ALUSrcControl $end
$var reg 1 B MemToRegControl $end
$var reg 1 @ branchBeqControl $end
$var reg 1 ? branchBltControl $end
$var reg 1 > branchJalControl $end
$var reg 1 < branchJalrControl $end
$var reg 3 e immControl [2:0] $end
$var reg 1 3 memWriteControl $end
$var reg 1 2 regWriteControl $end
$upscope $end
$scope module immediate_decoder $end
$var wire 3 f i_type [2:0] $end
$var wire 25 g imm_in [31:7] $end
$var reg 32 h imm_out [31:0] $end
$upscope $end
$scope module registerSet $end
$var wire 5 i a1 [4:0] $end
$var wire 5 j a2 [4:0] $end
$var wire 5 k a3 [4:0] $end
$var wire 1 $ clk $end
$var wire 32 l wd3 [31:0] $end
$var wire 1 2 we3 $end
$var reg 32 m rd1 [31:0] $end
$var reg 32 n rd2 [31:0] $end
$upscope $end
$upscope $end
$scope module dmem $end
$var wire 32 o address [31:0] $end
$var wire 1 $ clk $end
$var wire 32 p rd [31:0] $end
$var wire 32 q wd [31:0] $end
$var wire 1 ! we $end
$upscope $end
$scope module imem $end
$var wire 6 r address [5:0] $end
$var wire 32 s rd [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b101000000000001100010011 s
b0 r
bx q
bx p
bx o
bx n
bx m
b0x l
b110 k
bx j
b0 i
bx000000001010 h
b10100000000000110 g
b1 f
b1 e
b0 d
b0 c
b0 b
b101000000000001100010011 a
b10011 `
bx000000001010 _
bx ^
b0x ]
bx \
b0 [
bx Z
b0 Y
b0x X
bz W
b0x V
b0x U
b0x T
bx S
bx R
bx Q
b0x P
bx O
0N
b0x M
bx L
bx K
bx000000001010 J
b0 I
b0x H
bx G
b0 F
bx E
1D
b0 C
0B
b0x A
0@
0?
0>
b0x =
0<
bx ;
0:
b0x 9
bx 8
b1 7
bx000000001010 6
b101000000000001100010011 5
b0x 4
03
12
bx 1
bx 0
x/
bz .
bx -
bx ,
b0x +
bx *
bx )
bx (
b101000000000001100010011 '
b0x &
1%
1$
bx #
bx "
0!
$end
#1
0$
#2
b0x &
b0x +
b0x H
b0x ]
1$
0%
#3
0$
#4
1$
#5
0$
#6
1$
#7
0$
#8
1$
#9
0$
#10
1$
#11
0$
#12
1$
#13
0$
#14
1$
#15
0$
#16
1$
#17
0$
#18
1$
#19
0$
#20
1$
#21
0$
#22
1$
#23
0$
#24
1$
#25
0$
#26
1$
#27
0$
#28
1$
#29
0$
#30
1$
#31
0$
#32
1$
#33
0$
#34
1$
#35
0$
#36
1$
#37
0$
#38
1$
#39
0$
#40
1$
#41
0$
#42
1$
#43
0$
#44
1$
#45
0$
#46
1$
#47
0$
#48
1$
#49
0$
#50
1$
#51
0$
#52
1$
#53
0$
#54
1$
#55
0$
#56
1$
#57
0$
#58
1$
#59
0$
#60
1$
#61
0$
#62
1$
#63
0$
#64
1$
#65
0$
#66
1$
#67
0$
#68
1$
#69
0$
#70
1$
#71
0$
#72
1$
#73
0$
#74
1$
#75
0$
#76
1$
#77
0$
#78
1$
#79
0$
#80
1$
#81
0$
#82
1$
#83
0$
#84
1$
#85
0$
#86
1$
#87
0$
#88
1$
#89
0$
#90
1$
#91
0$
#92
1$
#93
0$
#94
1$
#95
0$
#96
1$
#97
0$
#98
1$
#99
0$
#100
1$
#101
0$
#102
1$
